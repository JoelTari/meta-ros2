From 120056aaa9f0caff6deda265eb6f198139a34016 Mon Sep 17 00:00:00 2001
From: Maxim Polyakov <maxim.polyakov@lge.com>
Date: Fri, 22 Jan 2016 17:10:43 +0300
Subject: [PATCH 2/3] Applying transformation matrices to svg

:Release Notes:
Currently, there is no way to apply transforms
like rotation, scale or translation while svg
is being rendering. This patch is resolve this
issue from the cairo side.

:Detailed Notes:

:Testing Performed:
Tested on PC, TV, Wearable

:QA Notes:

:Issues Addressed:
[PLAT-13078] Fix SVGImage world matrix application.

:Upstream-Status: Inappropriate
---
 src/cairo-egl-context.c | 14 ++++++++++++++
 src/cairo-gl-device.c   | 32 ++++++++++++++++++++++++++++++++
 src/cairo-gl-private.h  |  1 +
 src/cairo-gl-surface.c  |  3 +++
 src/cairo-gl.h          |  3 +++
 5 files changed, 53 insertions(+)

diff --git a/src/cairo-egl-context.c b/src/cairo-egl-context.c
index 022a85e..24add95 100644
--- a/src/cairo-egl-context.c
+++ b/src/cairo-egl-context.c
@@ -338,6 +338,20 @@ cairo_egl_device_create_raw()
     return &ctx->base.base;
 }
 
+void
+cairo_egl_surface_set_transform_matrix (cairo_device_t *device, cairo_surface_t *surface, const float *matrix) {
+    if(!device || !surface || !matrix)
+        return;
+
+    if (device->backend->type != CAIRO_DEVICE_TYPE_GL)
+        return;
+
+    cairo_egl_surface_t *egl_surface = (cairo_egl_surface_t*)surface;
+
+    if(matrix)
+        memcpy(egl_surface->base.transform_matrix, matrix, sizeof(egl_surface->base.transform_matrix));
+}
+
 static cairo_bool_t is_egl_device (cairo_device_t *device)
 {
     return (device->backend != NULL &&
diff --git a/src/cairo-gl-device.c b/src/cairo-gl-device.c
index 68384b8..23b884a 100644
--- a/src/cairo-gl-device.c
+++ b/src/cairo-gl-device.c
@@ -739,6 +739,36 @@ _cairo_gl_context_bind_framebuffer (cairo_gl_context_t *ctx,
     surface->msaa_active = multisampling;
 }
 
+void apply_surface_transform(cairo_gl_context_t *ctx, cairo_gl_surface_t *dst) {
+    float transformed_matrix[16];
+#define R(col,row)   transformed_matrix[col*4+row]
+#define M1(col,row)  ctx->modelviewprojection_matrix[col*4+row]
+#define M2(col,row)  dst->transform_matrix[col*4+row]
+    R(0,0) = M1(0,0) * M2(0,0) + M1(1,0) * M2(0,1) + M1(2,0) * M2(0,2) + M1(3,0) * M2(0,3);
+    R(0,1) = M1(0,1) * M2(0,0) + M1(1,1) * M2(0,1) + M1(2,1) * M2(0,2) + M1(3,1) * M2(0,3);
+    R(0,2) = M1(0,2) * M2(0,0) + M1(1,2) * M2(0,1) + M1(2,2) * M2(0,2) + M1(3,2) * M2(0,3);
+    R(0,3) = M1(0,3) * M2(0,0) + M1(1,3) * M2(0,1) + M1(2,3) * M2(0,2) + M1(3,3) * M2(0,3);
+
+    R(1,0) = M1(0,0) * M2(1,0) + M1(1,0) * M2(1,1) + M1(2,0) * M2(1,2) + M1(3,0) * M2(1,3);
+    R(1,1) = M1(0,1) * M2(1,0) + M1(1,1) * M2(1,1) + M1(2,1) * M2(1,2) + M1(3,1) * M2(1,3);
+    R(1,2) = M1(0,2) * M2(1,0) + M1(1,2) * M2(1,1) + M1(2,2) * M2(1,2) + M1(3,2) * M2(1,3);
+    R(1,3) = M1(0,3) * M2(1,0) + M1(1,3) * M2(1,1) + M1(2,3) * M2(1,2) + M1(3,3) * M2(1,3);
+
+    R(2,0) = M1(0,0) * M2(2,0) + M1(1,0) * M2(2,1) + M1(2,0) * M2(2,2) + M1(3,0) * M2(2,3);
+    R(2,1) = M1(0,1) * M2(2,0) + M1(1,1) * M2(2,1) + M1(2,1) * M2(2,2) + M1(3,1) * M2(2,3);
+    R(2,2) = M1(0,2) * M2(2,0) + M1(1,2) * M2(2,1) + M1(2,2) * M2(2,2) + M1(3,2) * M2(2,3);
+    R(2,3) = M1(0,3) * M2(2,0) + M1(1,3) * M2(2,1) + M1(2,3) * M2(2,2) + M1(3,3) * M2(2,3);
+
+    R(3,0) = M1(0,0) * M2(3,0) + M1(1,0) * M2(3,1) + M1(2,0) * M2(3,2) + M1(3,0) * M2(3,3);
+    R(3,1) = M1(0,1) * M2(3,0) + M1(1,1) * M2(3,1) + M1(2,1) * M2(3,2) + M1(3,1) * M2(3,3);
+    R(3,2) = M1(0,2) * M2(3,0) + M1(1,2) * M2(3,1) + M1(2,2) * M2(3,2) + M1(3,2) * M2(3,3);
+    R(3,3) = M1(0,3) * M2(3,0) + M1(1,3) * M2(3,1) + M1(2,3) * M2(3,2) + M1(3,3) * M2(3,3);
+#undef R
+#undef M1
+#undef M2
+    memcpy(ctx->modelviewprojection_matrix, &transformed_matrix[0], sizeof(transformed_matrix));
+}
+
 void
 _cairo_gl_context_set_destination (cairo_gl_context_t *ctx,
                                    cairo_gl_surface_t *surface,
@@ -789,6 +819,8 @@ _cairo_gl_context_set_destination (cairo_gl_context_t *ctx,
     else
 	_gl_identity_ortho (ctx->modelviewprojection_matrix,
 			    0, surface->width, surface->height, 0);
+
+    apply_surface_transform(ctx, surface);
 }
 
 void
diff --git a/src/cairo-gl-private.h b/src/cairo-gl-private.h
index cb915c8..2bc59b8 100644
--- a/src/cairo-gl-private.h
+++ b/src/cairo-gl-private.h
@@ -181,6 +181,7 @@ struct _cairo_gl_surface {
     cairo_bool_t msaa_active; /* Whether the multisampling
 			         framebuffer is active or not. */
     cairo_clip_t *clip_on_stencil_buffer;
+    GLfloat transform_matrix[16];
 
     int owns_tex;
     cairo_bool_t needs_update;
diff --git a/src/cairo-gl-surface.c b/src/cairo-gl-surface.c
index a68c24a..a12075e 100644
--- a/src/cairo-gl-surface.c
+++ b/src/cairo-gl-surface.c
@@ -396,6 +396,9 @@ _cairo_gl_surface_init (cairo_device_t *device,
     surface->needs_update = FALSE;
 
     _cairo_gl_surface_embedded_operand_init (surface);
+
+    static GLfloat default_matrix[16] = {1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1};
+    memcpy(surface->transform_matrix, default_matrix, sizeof(surface->transform_matrix));
 }
 
 static cairo_bool_t
diff --git a/src/cairo-gl.h b/src/cairo-gl.h
index 30ab95f..8d09cb3 100644
--- a/src/cairo-gl.h
+++ b/src/cairo-gl.h
@@ -150,6 +150,9 @@ cairo_gl_surface_create_for_egl (cairo_device_t	*device,
 cairo_public cairo_device_t *
 cairo_egl_device_create_raw();
 
+cairo_public void
+cairo_egl_surface_set_transform_matrix (cairo_device_t *device,
+                                   cairo_surface_t *surface, const float *matrix);
 cairo_public EGLDisplay
 cairo_egl_device_get_display (cairo_device_t *device);
 
-- 
2.7.4

